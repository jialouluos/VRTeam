<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ConvexGeometry</title>
    <script src="./../examples/js/utils/SceneUtils.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./../build/three.module.js"
            }
        }
    </script>
</head>

<body>
    <script type="module">
        //最新的three源码 把引入方式变了
        import * as THREE from 'three'
        import {OrbitControls} from './../examples/jsm/controls/OrbitControls.js'//打开我发群里的图片 我们来对对照看一下
        import Stats from './../examples/jsm/libs/stats.module.js' //你要看她到底加不加括号，这跟导入方式有关，现在记住就行，目前好像就只有Stats和GUI不需要加括号
        import {ConvexGeometry} from './../examples/jsm/geometries/ConvexGeometry.js'

        let renderer,scene,camera,light,stats,controls;

        const initRender = () => {
            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize(window.innerWidth,window.innerHeight);
            document.body.appendChild(renderer.domElement);
        }

        const initScene = () => {
            scene = new THREE.Scene();
        }

        const initCamera = () =>{
            camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000);
            camera.position.set(0,60,100);
            camera.lookAt(new THREE.Vector3(0,0,0));
        }

        const initLight = () =>{
            light = new THREE.PointLight(0xffffff);
            light.position.set(0,100,200);
            scene.add(light);
        }

        const initModel = () =>{
            generatePoints();
        }

        const generatePoints = () =>{
            let spGroup;
            let points = [];
            for( let i = 0; i < 20; i++ ){//const i时常量 不能被改编 你后面i++就不对
                //xyz轴的坐标点的位置会随机生成在+-150以内
                const randomX = -150 + Math.round(Math.random() * 300 );
                const randomY = -150 + Math.round(Math.random() * 300 );
                const randomZ = -150 + Math.round(Math.random() * 300 ); 

                //创建一个坐标点并添加到数组中
                points.push(new THREE.Vector3(randomX,randomY,randomZ));
            }
            //声明一个存放所有点的网格对象
            spGroup = new THREE.Object3D();
            //声明一个网格基础材质
            const material = new THREE.MeshBasicMaterial({color:0xff0000,transparent:false})
            //遍历数组生成小球点并添加到对象中
            points.forEach(function (point){
                const spGeom = new THREE.SphereGeometry(2);
                const spMesh = new THREE.Mesh(spGeom,material);
                spMesh.position.copy(point);//将当前小球的位置设置为当前点的坐标
                scene.add(spMesh);
            });
            //将存放点的对象添加到场景中
            scene.add(spGroup);
            //使用这些点实例化一个THREE.ConvexGeometry几何体对象
            const hullGeometry = new ConvexGeometry(points);
            //生成模型
            const hullMesh = createMesh(hullGeometry);
            //添加到场景
            scene.add(hullMesh);
        }

        const createMesh = (geom) =>{
            //实例化一个粉色半透明的材质
            const meshMaterial = new THREE.MeshBasicMaterial({color:"pink",transparent:true,opacity:0.2,side:THREE.Doubleside});
            const wireFrameMat = new THREE.MeshBasicMaterial();
            wireFrameMat.wireframe = true;//把材质渲染成线框

            //将两种材质都赋给几何体
            const mesh = THREE.SceneUtils.createMultiMaterialObject(geom,[meshMaterial,wireFrameMat]);

            return mesh;
        }

        const initStats = () =>{
            stats = new THREE.Stats();
            document.body.appendChild(stats.dom);
        }

        const initControls = () =>{//看到了吗
            controls = new OrbitControls(camera,renderer.domElement);
        }

        const Render = () =>{
            renderer.render(scene,camera);
        }

        //窗口变动触发的函数
        const onWindowResize = () =>{
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updaeProjectionMatrix();
            Render();
            renderer.setSize( window.innerWidth, window.innerHeight);
        }

        const aimate = () =>{
            //更新控制器
            controls.update();
            Render();

            //更新性能插件
            stats.update();
            requestAnimationFrame(animate);
        }
        
        const draw = () =>{
            initRender();
            initScene();
            initCamera();
            initLight();
            initModel();
            initControls();
            initStats();

            animate();
            window.onresize = onWindowResize;
        }
        window.onload = draw;
    </script>
</body>
</html>